import * as THREE from 'three';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { useGLTF } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { useFrame, useLoader, useThree } from '@react-three/fiber';
import { useUnit } from 'effector-react';
import { $hoverStore } from '@/store';
import useMouseMovement from '@/hooks/useMouseMovement';
import { motion } from 'framer-motion-3d';
import { PMREMGenerator } from 'three';
import { TextureLoader } from 'three';

import env from '@/public/masthead/environment-map.jpg';
import env2 from '@/public/masthead/environment-map2.png';
import env3 from '@/public/masthead/environment-map2.png';

type GLTFResult = GLTF & {
	nodes: {
		Cube001_Material002_0: THREE.Mesh;
	};
	materials: {
		['Material.002']: THREE.MeshStandardMaterial;
	};
};

export function MannequinHead(props: JSX.IntrinsicElements['group']) {
	const { nodes, materials } = useGLTF('/masthead/wig_mannequin.glb') as GLTFResult;
	const { scene, gl } = useThree();

	const pmremGenerator = new PMREMGenerator(gl);
	pmremGenerator.compileEquirectangularShader();

	const mouse = useMouseMovement();

	const modelRef = useRef(null);
	const uTimeRef = useRef({ value: 0 });
	const isHovering = useUnit($hoverStore);
	const [currentTextureIndex, setCurrentTextureIndex] = useState(0);
	const [hoverProcessed, setHoverProcessed] = useState(false);

	const texture = useLoader(TextureLoader, env.src);
	const texture2 = useLoader(TextureLoader, env2.src);
	const texture3 = useLoader(TextureLoader, env3.src);
	const textures = [texture, texture2, texture3];

	useFrame((state, delta) => {
		modelRef.current.rotation.y += delta * 0.5;
		uTimeRef.current.value += delta * 5;
	});

	useEffect(() => {
		if (modelRef.current && isHovering && !hoverProcessed) {
			setCurrentTextureIndex((prevIndex) => (prevIndex + 1) % textures.length);
			setHoverProcessed(true);
		} else if (!isHovering) {
			setHoverProcessed(false);
		}

		return () => {
			textures.forEach((texture) => texture.dispose());
		};
	}, [textures, isHovering, hoverProcessed]);

	useEffect(() => {
		if (scene && scene.environment) {
			const originalEnvMap = scene.environment;

			if (isHovering && pmremGenerator) {
				const envMap = pmremGenerator.fromEquirectangular(textures[currentTextureIndex]).texture;
				scene.environment = envMap;
			} else {
				scene.environment = originalEnvMap;
			}
			scene.environment.needsUpdate = true;

			return () => {
				pmremGenerator.dispose();
				textures.forEach((texture) => texture.dispose());
				scene.environment = originalEnvMap;
			};
		}
	}, [currentTextureIndex, textures, isHovering, scene]);

	const onBeforeCompile = useCallback(
		(shader: { uniforms: { uTime: { value: number } }; fragmentShader: string }) => {
			shader.uniforms.uTime = uTimeRef.current;
			shader.fragmentShader =
				`
		uniform float uTime;
		mat4 rotationMatrix(vec3 axis, float angle) {
			axis = normalize(axis);
			float s = sin(angle);
			float c = cos(angle);
			float oc = 1.0 - c;
			
			return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
						0.0,                                0.0,                                0.0,                                1.0);
		}
		
		vec3 rotate(vec3 v, vec3 axis, float angle) {
			mat4 m = rotationMatrix(axis, angle);
			return (m * vec4(v, 1.0)).xyz;
		}
		` + shader.fragmentShader;

			shader.fragmentShader = shader.fragmentShader.replace(
				`#include <envmap_physical_pars_fragment>`,
				`#ifdef USE_ENVMAP

			vec3 getIBLIrradiance( const in vec3 normal ) {
		
				#ifdef ENVMAP_TYPE_CUBE_UV
		
					vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		
					vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		
					return PI * envMapColor.rgb * envMapIntensity;
		
				#else
		
					return vec3( 0.0 );
		
				#endif
		
			}
		
			vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		
				#ifdef ENVMAP_TYPE_CUBE_UV
		
					vec3 reflectVec = reflect( - viewDir, normal );
		
					// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
					reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		
					reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

					reflectVec = rotate(reflectVec, vec3(1.0, 0.0, 0.0), uTime * 0.3);
		
					vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		
					return envMapColor.rgb * envMapIntensity;
		
				#else
		
					return vec3( 0.0 );
		
				#endif
		
			}
		
			#ifdef USE_ANISOTROPY
		
				vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
		
					#ifdef ENVMAP_TYPE_CUBE_UV
		
					  // https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy
						vec3 bentNormal = cross( bitangent, viewDir );
						bentNormal = normalize( cross( bentNormal, bitangent ) );
						bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
		
						return getIBLRadiance( viewDir, bentNormal, roughness );
		
					#else

						return vec3( 0.0 );

					#endif

				}

			#endif

		#endif`,
			);
		},
		[],
	);

	return (
		<>
			<motion.group {...props} dispose={null} ref={modelRef} rotation-y={mouse.x} rotation-x={mouse.y}>
				<mesh
					castShadow
					receiveShadow
					geometry={nodes.Cube001_Material002_0.geometry}
					material={materials['Material.002']}
					position={[0, -7, 0]}
					rotation={[-Math.PI / 2, 0, 0]}
					scale={1}
				>
					<meshStandardMaterial metalness={1} roughness={0.28} onBeforeCompile={onBeforeCompile} />
				</mesh>
			</motion.group>
		</>
	);
}

useGLTF.preload('/wig_mannequin.glb');
